% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qra_fit_convenience.R
\name{build_covid_ensemble}
\alias{build_covid_ensemble}
\title{Read in covid forecasts from local files and fit one ensemble}
\usage{
build_covid_ensemble(
  hub,
  source,
  hub_repo_path,
  candidate_model_abbreviations_to_include,
  spatial_resolution,
  targets,
  forecast_date,
  as_of,
  forecast_week_end_date,
  max_horizon,
  timezero_window_size = 1,
  window_size,
  data_as_of_date,
  forecast_date_locations_drop = NULL,
  target_end_date_locations_drop = NULL,
  intercept = FALSE,
  combine_method,
  quantile_groups,
  noncross = "constrain",
  missingness,
  impute_method,
  backend,
  required_quantiles,
  check_missingness_by_target,
  do_q10_check,
  do_nondecreasing_quantile_check,
  do_baseline_check,
  do_sd_check,
  sd_check_table_path = NULL,
  sd_check_plot_path = NULL,
  baseline_tol = 1.2,
  top_models = 0,
  manual_eligibility_adjust,
  return_eligibility = TRUE,
  return_all = TRUE,
  partial_save_frequency,
  partial_save_filename
)
}
\arguments{
\item{hub}{character vector, where the first element indicates the hub
from which to load forecasts. Possible options are "US" and "ECDC";
passed to covidHubUtils::load_latest_forecasts}

\item{source}{string specifying where forecasts will be loaded from: either
"local_hub_repo" or "zoltar";
passed to covidHubUtils::load_latest_forecasts}

\item{hub_repo_path}{path to local clone of the reichlab/covid19-forecast-hub
repository to be used when \code{source} is \code{local_hub_repo};
passed to covidHubUtils::load_latest_forecasts}

\item{candidate_model_abbreviations_to_include}{List of model abbreviations
for models that may be included in ensemble forecast}

\item{targets}{character vector of targets to retrieve, for example
c('1 wk ahead cum death', '2 wk ahead cum death')}

\item{forecast_date}{the forecast date for the analysis, typically a Monday}

\item{as_of}{"as_of" date passed to zoltar
Ignored if \code{source} is \code{"local_hub_repo"}.}

\item{forecast_week_end_date}{date relative to week-ahead or day-ahead
targets are defined. For week ahead targets, a Saturday; for day ahead
targets, a Monday.}

\item{max_horizon}{maximum horizon for ensemble forecasts}

\item{timezero_window_size}{The number of days back to go.  A window size of
0 will retrieve only forecasts submitted on the \code{last_timezero} date.}

\item{window_size}{size of window}

\item{data_as_of_date}{date for which observations should be current}

\item{intercept}{logical specifying whether an intercept is included}

\item{combine_method}{character specifying the approach to model
combination: "equal", "convex", "positive", "unconstrained", "median",
or "convex_median".
The first four form a linear combination of quantiles across component
models with varying levels of restrictions on the combination coefficients.
"median" takes the median across models at each quantile level, and
"convex_median" uses a weighted median with convext constraints on weights}

\item{quantile_groups}{Vector of group labels for quantiles, having the same
length as the number of quantiles.  Common labels indicate that the ensemble
weights for the corresponding quantile levels should be tied together.
Default is rep(1,length(quantiles)), which means that a common set of
ensemble weights should be used across all levels.  This is the argument
\code{tau_groups} for \code{quantmod::quantile_ensemble}, and may only be supplied if
\verb{backend = 'quantmod}}

\item{noncross}{string specifying approach to handling quantile noncrossing:
one of "constrain" or "sort". "constrain" means estimation is done subject
to constraints ruling out quantile crossing.  "sort" means no such
constraints are imposed during estimation, but the resulting forecasts are
sorted.}

\item{missingness}{character specifying approach to handling missing
forecasts: 'by_location_group', 'rescale', or 'impute'}

\item{impute_method}{character string specifying method for imputing missing
forecasts; either 'mean' for mean imputation or 'none' for no imputation}

\item{backend}{back end used for optimization.}

\item{required_quantiles}{numeric vector of quantiles component models are
required to have submitted}

\item{check_missingness_by_target}{if TRUE, record missingness for every
combination of model, location, forecast week, and target; if FALSE, record
missingness only for each model and location}

\item{do_q10_check}{if TRUE, do q10 check}

\item{do_nondecreasing_quantile_check}{if TRUE, do nondecreasing quantile check}

\item{return_eligibility}{if TRUE, return model eligibility}
}
\value{
data frame with ensemble forecasts by location
}
\description{
Read in covid forecasts from local files and fit one ensemble
}
